# Java并发

- 将能同时处理多个任务的软件称为并发软件

  - 从Java5以来，Java平台就有了高并发API

  - java.util.concurrent库

- 创建进程可以使用ProcessBuilder，但这超出了接下来的讨论范围。

  - Java并发目前只讨论线程

- Thread对象

  - 每个线程都和一个Thread对象相关联，有两种方法使用Thread对象创建并发程序

    - 直接控制线程的创建和管理，当应用需要初始化一个异步任务时，每次都实例化Thread

    - 要从应用程序的其余部分抽象线程管理，将应用程序的任务传递给一个executor。

  - 定义并开始一个线程

    - 要实例化Thread对象，必须提供将会运行在这个线程中的代码

      - 给Thread构造器传入一个实现了Runnable接口的对象

      - 创建继承自Thread的一个子类，然后重写Thread的run()方法

    - 然后对创建的Thread对象调用start()方法。

    - 上面的两种方法各有特点：

      - 自己实现Runnable接口更具一般性，可以继承其他类

      - 继承Thread用起来更方便，但父类必须是Thread会有所限制。

      - 在高级线程管理API中，第一种更适用。

  - 用睡眠停止线程的执行

    - 静态方法Thread.sleep()暂停当前线程的执行

    - 向sleep()方法传入一个整数，代表要睡眠的时间，默认单位是毫秒

    - sleep()不能保证精确的睡眠时间，因为这实际会被底层操作系统限制，并且睡眠期间还可能被中断型号终止。

    - sleep()方法抛出检查型异常InterruptedException。

      - 当另一个线程中断了当前正在睡眠的线程时，sleep方法就抛出该异常

  - 中断

    - 一个中断信号表示这个线程应该停下现在的工作去做点别的。具体由程序员决定线程该如何响应中断。其中

    - 在其他线程里对要中断的线程对象调用interupt()方法就能中断对应的线程。

      - 要让中断机制正确工作，被中断的线程必须支持自己的中断。

    - 受支持的中断

      - 要被中断的线程调用抛出InterruptedException的方法（如sleep），即支持中断。

        - 在try-catch语句中，一般捕获到异常后直接返回。

      - 如果一个线程很长时间没有调用抛出InterruptedException的方法怎么办？那么它必须定期调用Thread.interrupted()，如果收到中断信号，它将返回true。

        - 当这个方法返回true时，再手动抛出InterruptedException异常更好，这样可以在外层嵌套中用try-catch语句来集中处理异常。

      - 中断状态标志

        - 中断机制使用称为中断状态的内部标志实现。调用Thread.interrupt将设置此标志。当线程通过调用静态方法Thread.interrupted检查中断时，中断状态将被清除。非静态isInterrupted方法由一个线程用来查询另一个线程的中断状态，它不会更改中断状态标志。

        - 按照约定，任何通过抛出InterruptedException退出的方法都会在抛出时清除中断状态。但是，总是有可能由另一个线程调用中断，立即再次设置中断状态。

  - join()方法

    - join()方法允许一个线程等待另一个线程的完成

    - 可以重载join方法：传入指定的等待时间

    - join也会想sleep那样抛出InterruptedException异常

- 同步

  - 线程主要通过共享对字段和引用字段引用的对象的访问来进行通信。这种形式的通信效率极高，但可能导致两种错误：线程干扰和内存一致性错误。防止这些错误所需的工具是同步。

    - 但是，同步可能会引入线程争用，当两个或多个线程试图同时访问同一资源时会发生这种情况，并导致Java运行时更慢地执行一个或多个线程，甚至暂停它们的执行。饥饿和活锁都是线程争用的形式。有关详细信息，请参阅“活动性”一节。

  - Java语言提供了两种同步用法——同步的方法和同步的语句

    - 同步方法

      - 在方法声明中添加synchronized关键字

      - 对同一个对象的两个同步方法的调用不可能交错。当一个线程正在执行某个对象的同步方法时，为同一对象调用同步方法的所有其他线程都会阻塞（挂起执行），直到第一个线程处理完该对象。

      - 构造器不能是同步的，在构造器前加synchronized关键字引发语法错误。

    - 同步语句

      - 与同步方法不同，同步语句必须指定提供内部锁的对象

      - 同步语句的好处

        - 非同步方法里可以同步读写字段。对字段的读写一般必须是同步的，但可能这个方法里还会调用其他对象的方法

        - 交错读写同一对象的多个字段。对象的同步方法直接锁住了整个对象，同时只能有一个线程读写字段，如果为每个字段对应创建一个用来提供锁的对象，就可以做到多个线程分别读写多个字段。

  - 同步方法是通过内部锁实现的

    - 当对一个对象调用同步方法时，自动获得该对象的内部锁，所有其他要调用该对象的同步方法的线程因无法获取锁而阻塞

      - 方法返回时自动释放锁，即使发生了异常也会自动释放锁

    - 静态同步方法的锁是类的Class对象的锁，该锁与类的任何实例的锁不同

    - 一个线程不能获取另一个线程拥有的锁。但是线程可以获取它已经拥有的锁。允许线程多次获取同一锁将启用可重入同步。这描述了同步代码直接或间接调用也包含同步代码的方法，并且两组代码使用同一锁的情况。如果没有可重入同步，同步代码将不得不采取许多额外的预防措施，以避免线程导致自身阻塞。

- 活动性liveness

  - 死锁——两个或多个线程被永久阻塞、相互等待的情况。

  - 饥饿——一个线程总是不能正常访问一个共享资源，一般是其他线程频繁调用共享对象的同步方法

  - 活锁——一个线程经常响应另一个线程的操作而执行操作。如果另一个线程的动作也是对另一个线程的动作的响应，则可能导致活锁。与死锁一样，活锁线程无法继续前进。然而，线程并没有被阻塞--它们只是忙碌响应彼此而无法继续工作。

- 受保护的块

  - 线程间经常要协调它们的活动。最常见的协调写法被称为受保护的块。

    - 这样的块通过轮询一个条件开始，只有条件为真时线程才能继续。

    - 比如，两个线程（A和B）间用一个共享的boolean变量flag来通信。A用一个while循环来判断flag是否为真，只有当B将flag设置为真时，A才能向下执行。

      - while循环内应该用Object.wait()来停止本线程。

        - 当前线程必须拥有Object的锁才能调用wait()方法，否则抛出异常。调用后，当前线程自动释放锁，并等待被其他线程用notify或notifyAll方法唤醒，然后继续等待，直到重新获得锁，然后wait()返回，继续执行。

        - 在单参数版本中，中断和伪唤醒是可能的，并且此方法应始终在循环中使用

  - 使用受保护的块的方法（如guardedBlocks()）应该是同步的（synchronized），while循环里直接对本实例对象调用wait()（即this.wait()，编写guardedBlocks()方法时可省略this）。

    - 因为wait方法要求线程拥有对象的锁，如果guardedBlocks()方法不是同步的，调用wait时，锁可能在其他线程里，就调用失败了。将guardedBlocks()方法设置为同步的，调用wait时，锁必然在当前线程中。
