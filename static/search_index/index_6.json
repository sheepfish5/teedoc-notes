{"/Java/index.html":{"title":"Java","content":" title: Java keywords: Java date: 2023 07 19 关于Java的学习内容"},"/Java/vscode中的JUnit.html":{"title":"vscode中的JUnit","content":"# vscode中的JUnit 基本全自动。 装了Java插件包（Extension Pack for Java）后，选边栏上的测试图标，点一下自动配置，选`JUnit Jupyter`，然等待自动下载就行了。 具体使用也只需要在写好的测试方法上加`@Test`注解就行了。 常用注解包括`@Before` `@After` `@Test` `@BeforeEach` `@AfterEach`。主要还是一个`@Test`就足够用了。 注意vscode里的Java测试无法输出到控制台，得用日志。"},"/Java/maven常用指令.html":{"title":"","content":"使用exec maven plugin插件运行maven项目（需要给插件配置mainClass属性）： ~~~bash mvn exec:java ~~~ > [参考回答](https://stackoverflow.com/questions/1089285/maven run project)"},"/Java/JavaEE学习.html":{"title":"","content":"## Servlet中使用cookie实现Session ### 前提 http是没有状态的，Web应用无法分别出两个http请求是否来自同一个浏览器。比如用户A先请求Get index.html，在这一个html中插入了一张图片，于是浏览器又立即请求Get image.png，Web应用实际把这两个请求看成没有联系的独立的请求。 如果为同一个用户短时间内发送的所有请求分配一个识别码，这样的话，Web应用就可以把包含这个识别码的请求归为同一个用户发送的。当然，这个识别码是有时效的，超出这个失效后，Web应用就不认了。 我们将Web应用识别同一用户短时间内发送的请求称为`会话（Session）`，承载这个识别码的是HTTP协议中的Cookie机制。也就是说，Cookie配合唯一识别码实现了Session机制。 ### Servlet中的HttpSession 当对用户发送的请求第一次调用getSession()方法时，Servlet底层机制自动在内存中生成一个识别码到HttpSession对象的映射，同时做出如下动作： 本次Web应用响应时会附带一个名为JSESSIONID的Cookie，内容就是这个识别码，之后用户发送的请求都会带上这个识别码。 getSession()同时将HttpSession对象返回，可以对这个HttpSession对象调用getAttribute()方法，附带上有关用户本次会话的信息，方便其他Servlet使用。 下次用户的请求中带有Cookie时，再对请求调用getSession()方法，就会返回之前的HttpSession对象。"},"/Java/Java基础/匿名类和嵌套类的Class对象.html":{"title":"匿名类和嵌套类的Class对象","content":"# 匿名类和嵌套类的Class对象 ## 匿名类 Class对象是反射API的入口，要想启用Java的反射特性，一般首先要获得对应类的Class对象。 创建匿名类的语法： ~~~Java Object anonymous new Object() { public void m() {} }; ~~~ 创建了一个继承自`Object`的匿名类，直接实例化了一个对象，并用变量`anonymous`引用了这个变量。 获取匿名类的Class对象，并直接输出`toString()`方法的结果 ~~~Java Class<?> c anonymous.getClass().getEnclosingClass(); System.out.println(c.toString()); ~~~ 最后输出的结果是`class test.AnnotationToolTest$1`(变量`anonymous`和`c`都是类`test.AnnotationToolTest`下的静态字段) 这个输出结果*猜测*是和Java匿名类的实现有关，我*猜测*它可能在编译时自动创建了一个名为`test.AnnotationToolTest$1`的有名类。 ## 嵌套类 我们再来看看嵌套类Class对象的`toString()`方法输出 在`test.AnnotationToolTest$1`类下有一个静态嵌套类`NestedClass`: ~~~Java static class NestedClass { public void tmp() {} } ~~~ 在enclosing class的main方法中，输出该嵌套类Class对象`toString()`方法的结果： ~~~Java System.out.println(NestedClass.class.toString()); ~~~ 结果为`class test.AnnotationToolTest$NestedClass` 同样猜测，这个输出结果应该和Java嵌套类的实现有关，Java可能在编译时自动创建了一个名为`test.AnnotationToolTest$NestedClass`的有名类。就像泛型的类型擦除一样，JVM实际不知道Java有泛型这种特性。 ## 验证Java泛型的类型擦除 通过《Java 核心技术 卷一》和Java官网的描述，Java会在编译时对泛型进行类型擦除，因此运行时，就已经没有泛型的类型参数了，类型参数出现的地方会被替换成Object或（有束缚时）上界类型。 反射API正好是在运行时起作用，可以向上面那样运行时输出类的类名， ~~~Java static List<Integer> list new ArrayList<>(Arrays.asList(1, 2, 3, 4)); ~~~ 还是`test.AnnotationToolTest$1`类里的静态字段，`list`引用了一个`ArrayList<Integer>`对象，`getClassf()`获取`ArrayList<Integer>`的Class对象，然后再用`toString()`方法输出： ~~~Java System.out.println(list.getClass().toString()); ~~~ 结果是`class java.util.ArrayList`，而不是`ArrayList<Integer>`，可以验证，类型参数已经被擦除了。 ## Class的类方法getCanonicalName() 对于上面提到的三种情况：匿名类，嵌套类，实例化的泛型类，如果不是直接对它们的Class对象用`toString()`方法输出，而是使用`getCanonicalName()`，情况会有所不同，输出分别是： 匿名类：`null` 嵌套类：`test.AnnotationToolTest.NestedClass` 实例化的泛型类：`java.util.ArrayList` 除了泛型类还是正常类型擦除，其他两个都有所变化：匿名类的规范名直接是null了，嵌套类有规范名。 在[Java官网关于`getCanonicalName()`的说明中](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getCanonicalName )就提到如果Class对应的类没有规范名的话（[局部类](<https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html> 说人话就是定义在方法里的类)和匿名类，以及没有规范名的类组成的数组），就返回null。规范名是由Java语言规范定义的。 那么看来嵌套类是有规范名的。 ## toGenericString()方法输出泛型声明的类型参数（但不能输出泛型实例化时传入的类型参数） 对于泛型类型输出没有类型参数的情况，`toGenericString()`方法输出泛型声明的类型参数。比如对上面的`ArrayList<Integer>`的Class对象使用，输出为`public class java.util.ArrayList<E>`。 至少能表明这是一个泛型类，但还是不能输出泛型实例化时传入的类型参数（在这里是`Integer`）。 `Field`，`Method`，`Constructor`等对象也分别有`toGenericString()`方法，可以输出泛型声明时的类型参数。"},"/Java/黑马程序员-苍穹外卖/1.新增员工技术要点.html":{"title":"新增员工技术要点","content":"# 新增员工技术要点 ## 一般功能开发流程 1. 确定需求 新增员工 2. 确定接口 3. Controller > Service > Dao ## 心得 测试：可以先用Swagger测试，之后再前后端联调 使用Swagger测试时，注意拦截器会检查token，要先获取一个有效token加在请求头中 测试时可以使用IDEA的断点调试 各种地方，使用到的int常量、字符串常量等，全部使用工具类的静态常量 ## 注意1 解决用户名重复时，Dao层会抛出异常。可以用全局异常处理来处理对应的SQL异常。 具体就是提取出SQL异常附带的重复的用户名，返回给前端。 ## 注意2 Service层要获取token中的empId，可以用一个全局静态ThreadLocal对象。 拦截器将empId放入ThreadLocal对象，Service层取出使用。"},"/Java/黑马程序员-苍穹外卖/2.员工分页查询技术要点.html":{"title":"员工分页查询","content":"# 员工分页查询 ## 心得 Controller层接收URL参数时，也要把所有参数（name、page、pageSize）包成一个类（EmployeeDTO）来接收，而不要直接写成三个分散的参数。 分页查询时，三个参数（name、page、pageSize）封装成一个对象从Controller一路传到Dao层就行，具体有没有name，交给Mybatis的动态SQL处理。 注意一下PageHelper分页插件的使用。引入pagehepler的starter后，就不需要另外配置了 Service层调用Dao层获得结果后，将结果封装到类PageResult对象中 不断把各种零散的数据封装成一个大的对象，方便各层之间相互传递参数（一个参数比多个零散参数更简洁），增强代码可读性、项目可维护性。"},"/Java/Java学习/枚举类.html":{"title":"枚举类","content":"# 枚举类 枚举类型是特殊的类。枚举使变量引用一系列预先定义好的常量。枚举类型的变量必须等于已经预定义好了的常量之一。 因为是常量，枚举类相的字段名都是大写字母。 使用enum关键字定义枚举类型 当要表示固定的一列常量时，应该用枚举类型。 Java的枚举类型很强大。enum声明定义了一个类，能包括方法和其他字段。创建一个枚举时，编译器自动加入特殊方法。 如values()静态方法，返回一个包含所有枚举值的数组。一般用这个方法配合for each，来遍历所有枚举值。 枚举隐式继承了java.lang.Enum，不能再继承其他东西了 枚举类的实例必须在其他方法和字段之前定义。 枚举类的构造器要么没访问级别修饰符（package private），要么是private。 不能自行调用枚举构造器，即不能在枚举定义之外创建实例。 枚举实例在创建时就应传入实参到构造器中。 除了上述限制外，枚举就和普通类一样，都能有public方法，静态方法 也能有main方法，作为mainClass直接运行也是可以的。"},"/Java/Java学习/Java标准日历.html":{"title":"Java标准日历","content":"# Java标准日历 ISO日历遵守the proleptic Gregorian rules，Gregorian rules于1582年被提出，预期日期从那个时间向后延伸以创建一致的、统一的时间轴并简化日期计算 概述 时间包括两种——人类时间和机器时间 人类时间：年月日，时分秒 机器时间：以纳秒为单位，沿着时间线从被称为Epoch（1970年1月1日00:00:00 UTC）的起点开始不断计时 要使用时间，先选择时人类时间还是机器时间，如果是人类时间，再考虑时区，再考虑日期还是时间，如果是日期，选年月日中的哪几个？ 两个枚举：DayOfWeek和Month DayOfWeek 七个常量：MONDAY到SUNDAY 每个常量对应一个整数，MONDAY对应1，SUNDAY对应7 有许多类似核心类的方法 如MONDAY.plus(3)返回THURSDAY getDisplayName(TextStyle, Locale) TextStyle是一个枚举类型，预定义好了时间表示格式：FULL，NARROW，SHORT，STANDALONE（不常用）。 Month 分别包括十二个月的常量，从JANUARY到DECEMBER 每个常量对应一个整数，从1到12 有许多方法 maxLength()方法返回一个整数，代表这个月的最大天数 也有getDisplayName()方法，用法和DayOfWeek类似。 日期类 日期时间API有四个类专门处理日期信息，不带时间或时区：LocalDate，YearMonth，MonthDay和Year LocalDate以ISO格式表示年月日，不带时间。 可以用LocalDate来代表生日和结婚日这样的事件。 of()方法：LocalDate date LocalDate.of(2000, Month.NOVEMBER, 20); with()方法：LocalDate nextWed date.with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY)); 有许多getter方法返回给定日期的信息，如getDayOfWeek()。 YearMonth类代表指定年的某一月 now()方法和lengthOfMonth()方法：YearMonth.now().lengthOfMonth() MonthDay类代表特定月的某一天 isValidYear()方法：此方法检查此月和日与输入的年是否构成有效日期。只有当MonthDay是2月29日时才可能返回false。 Year类代表某一年 isLeap()方法判断是不是闰年。 日期和时间类 LocalTime类和其他以Local为前缀的类相似，但它只有时间 LocalTime类用来表示人类时间，如电影开播时间，图书馆开门关门时间。 三个方法：getHour()，getMinute()，getSecond()。 LocalTime不存储时区和夏令时信息。 LocalDateTime类同时处理日期和时间，但没有时区。 这个类是LocalDate和LocalTime的结合，用来表示某个特殊的事件，如纪念九一八事变防空警报是在9月18日9时18分拉响的。 特别注意，像这个9时18分是当地时间。 使用ZonedDateTime或OffsetDateTime类的对象来表示时区时间。 基础的now()方法，of()方法 from()方法：将其他时间格式转成LocalDateTime实例 plueMonth()，minusMonth() 时区和偏移类 每个时区都有一个标识符，格式是region/city（如Asia/Tokyo），还有一个UTC偏移量，如Tokyo的偏移量是+09:00。 日期时间API提供两个类来指定一个时区或偏移量：ZoneId类和ZoneOffset类 前者指定一个时区标识符，并提供了Instant和LocalDateTime对象之间转换的规则 后者指定了时间的偏移量 一般偏移量都是整数个小时，但也有些例外 日期时间类 有三个基于时间的类用来处理时区 ZonedDateTime处理日期和时间，并带有一个对应的时区和偏移量 OffsetDateTime处理日期和时间并带有一个时间偏移量，没有时区ID OffsetTime只有时间和时间偏移量 何时使用OffsetDateTime代替ZonedDateTime？如果您正在编写复杂的软件，该软件基于地理位置为自己的日期和时间计算规则建模，或者如果您正在将时间戳存储在仅跟踪相对于格林威治/UTC时间的绝对偏移量的数据库中，则可能需要使用OffsetDateTime。此外，XML和其他网络格式将日期时间传输定义为OffsetDateTime或OffsetTime。 ZonedDateTime在效果上联合了LocalDateTime和ZoneId，被用来表示完整的时间 配合ZoneRules对象的isDaylightSavings()方法来判断夏令时 OffsetDateTime类联合了LocalDateTime类和ZoneOffset类，被用来表示完整的时间（年月日时分秒还有偏移量） OffsetTime类联合了LocalTime和ZoneOffset类，存储了时间和时间偏移量 Instant类（即时类） 存储的是从epoch以来的纳秒。 这个类可用来生成时间戳和表示机器时间。 在epoch之前的Instant存的是负值，之后的存的是正值 各种方法 MAX和MIN常量表示最小时间和最大时间 toString()方法返回ISO 8601规范的时间字符串 plus()方法和minus()方法，增减时间 isAfter()方法和isBefore()方法用来比较 until()方法返回两个Instant之间差的时间 如果要算年月日时分秒，需要转成其他对象，转换的时候需要提供Instant的时区 使用其他类的ofInstant()方法可以转成其他类 ZonedDateTime和OffsetDateTime对象可以直接转成Instant对象，但反过来不可以，除非提供时区或偏移量信息。 解析和格式化 基于时间的类提供了解析字符串中时间信息的方法；也提供了格式化为字符串的方法。 两个过程是类似的：向DateTimeFormatter提供一个模式字符串来创建一个格式对象，然后将格式对象传给解析方法或格式化方法。 DateTimeFormatter类提供了许多预先定义好的格式对象。当然我们也可以定义我们自己的。 当在转换过程中发生问题时，解析和格式化方法会抛出异常。 DateTimeFormatter类是不可变的，并且是线程安全的。 合适的话，应把它赋值给一个静态常量。 java.time日期 时间对象可以直接与java.util.Formatter和String.format一起使用，方法是使用与遗留java.util.Date和java.util.Calendar类一起使用的熟悉的基于模式的格式。 parse() LocalDateTime中的一个参数的parse()方法使用ISO_LOCAL_DATE格式对象 要使用不同的格式对象，就用两个参数的parse()方法，第一个参数是模式字符串，第二个参数就是格式对象了。 使用静态方法ofPattern()创建格式对象，传入类似\"MMM d yyyy\"的模式字符串 模式字符串详细信息： <https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns> parse()一般是某个日期时间类的静态方法，传入输入字符串和格式对象，传出对应的日期时间对象 format() format()是某个日期时间类的实例方法，传入格式对象，返回字符串。 java.time.temporal包 这个包提供了许多最底层的接口，我们最好是直接用LocalDate，ZonedDateTime这样的类，而不是实例化那些底层接口 Temporal接口 该接口提供了访问日期时间的对象，被那些日期时间的类实现了。 这个接口提供了加减时间单元的方法，使时间算术简单且在各个类之间一致。 TemporalAccessor接口提供了只读版本 。。。 ChronoField枚举类实现了TemporalField接口 提供了许多常量来访问日期和时间值 如CLOCK_HOUR_OF_DAY，NANO_OF_DAY和DAY_OF_YEAR 这个枚举表示如今年的第三周，今天的第十一各小时这样的时间概念。 日期时间对象.get(枚举值)，返回对应的时间对象 使用对象.isSupported(枚举值)，判断该对象是否支持对应的枚举值 这个枚举提供了基于字段操作日期时间对象的方式 ChronoUnit枚举实现了Temporal接口，提供了一系列基于日期时间的从毫秒到千年的单元。 注意不是所有的枚举值都被所有的类支持 类对象.isSupported(枚举值)，判断对象是否支持枚举值 TemporalAdjuster接口 该接口提供许多方法：传入一个时间值，返回调整后的值。 调整器能被任何日期时间对象使用 如果调制器和ZonedDateTime一起使用，返回新对象，以保留原来的对象 预定义好的调整器 TemporalAdjusters（注意复数）类提供了预定义好的调整器 包括找出月的第一天和最后一天，一年的第一天和最后一天，一个月的最后一个星期三，或指定日期之后的第一个星期四。 预定义好的调整期被定义为静态方法，并设计成以静态导入的形式使用。 使用方法是配合对象的with方法使用：date.with(adjuster) 定制自己的调整器 TemporalAdjuster是一个函数式接口，要定制调整器，只要编写实现了该接口的类。 调用时再传入实例对象到with()方法中去，和调用预定义调整器相同。 时间查询TemporalQuery 时间查询类用来从日期时间对象中检索信息 预定义的查询 如precision查询，返回日期时间对象支持的最小时间单位（如LocalDate最小支持年） TemporalQuery<查询信息类型> query TemporalQueries.precision(); LocalDate.now().query(query); TemporalQueries类以静态工厂方法的形式预定义了许多时间查询 定制查询 编写实现了TemporalQuery接口的类来定制查询 或者写一个合适的方法，以方法引用的方式调用这个方法。 周期和持续时间（Period和Duration） Period类和Duration类，还有ChronoUnit.between()方法可用来表示一段时间 Duration基于机器时间，使用纳秒计数。它提供转换为时分秒的方法。 当被创建时使用的时间终点发生在开始点之前时，Duration为负值 Duration不和时间线保持联系，它没有时区或夏令时相关信息。 用Duration给ZonedDateTime加一天，就是相当于直接加24小时，直接无视夏令时的某些特殊情况 ChronoUnit枚举类预定了常量来计量时间。实例方法between()返回两个时间点之间时间单位的个数 如ChronoUnit.Month((代表2月18号的对象), (4月23号))返回2 Period类用来定义一定数量的基于日期的时间值 如果说ChronoUnit以单个时间单位表示时间段，那Period就是以年月日为单位表示时间段，比如用Period表示年龄多大。 如果不要求时区和夏令时等，直接使用LocalDateTime配合Period，如果涉及到时区和夏令时等，使用ZonedDateTime Clock 大部分类有无参数方法now()，提供了系统时钟的日期和时间，还有默认的时区。 这些类还有一个now(Clock)方法，我们可以传入一个Clock对象 现在的时间依靠时区，对于全球化的应用，要用Clock类确保日期时间有正确的时区。 虽然Clock是可选的，但这个特性让我们能使用不同的时区测试我们的代码。或使用固定的时钟，让测试时的时间不变 Clock是个抽象类，不能创建它的实例对象。有一些工厂方法 Clock.offset(Clock，Duration)返回一个偏移了指定Duration的时钟。 Clock.systemUTC()返回表示格林威治/UTC时区的时钟。 Clock.fixed(Instant, ZoneId)始终返回相同的即时。对于这个钟来说，时间静止了。 非ISO日期转换 Java日期时间API总结： Java日期时间API是用来处理日期，时间，时区以及其他历法的一系列包，类和接口的总和。 基于时间的类有许多特定前缀开头的方法，命名规范将前缀和功能紧密联系起来。"},"/Java/Java学习/注解annotation.html":{"title":"","content":"## 定义 annotation（注解），一种元数据，提供一个程序的相关信息，但它本身并不是程序的一部分。annotation对它所注解的代码的动作没有直接影响。 ## 三种annotation 1. 提供给编译器的信息——方便编译器错误检查或suppress warnings 2. 编译时和开发时处理——有专门的软件工具（如Javadoc）通过annotation生成代码、XML文档等等 3. 运行时处理——有些annotation在运行时发挥作用 ## annotation格式 基本格式： ~~~Java @Override void mySuperMethod() {...} ~~~ 以@符开头表示annotation annotation可以包含有名字或无名字的elements： ~~~Java @Author( name \"Benjamin Franklin\" date \"3/27/2003\" ) class MyClass {...} ~~~ 如果只有一个名为value的element，可以直接省略value： ~~~Java @SuppressWarings(\"unchecked\") ~~~ 如果一个element都没有，那就不用带括号，就像`@Override`一样。 可以对一个声明用多个注解： ~~~Java @Author(name \"Jane Doe\") @EBook class MyClass {...} ~~~ 有的annotation类型已经在Java SE API的java.lang或java.lang.annotaion包中预定义好了。我们也可以定义自己的annotation类型，前面例子中的Author和EBook就是自定义的。 ## annotations可以用在哪 annotations可以用在各种声明中，包括类、字段、方法和其他程序元素的声明。 约定俗成：当annotations被用于声明中时，每个annotation单独占一行。 ## 声明一个annotation类型 可以用annotation替代部分代码中的注释 假设一个软件开发小组传统地在每个类的前面加上下面的注释来提供重要信息： ~~~Java public class Generation3List extends Generation2List { // Author: John Doe // Date: 3/17/2002 // Current revision: 6 // Last modified: 4/12/2004 // By: Jane Doe // Reviewers: Alice, Bill, Cindy // class code goes here } ~~~ 为了用annotation替代注释来提供这些信息，我们需要首先定义一个annotation类型，语法如下： ~~~Java @interface ClassPreamble { String author(); String date(); int currentRevision() default 1; String lastModified() default \"N/A\"; String lastModifiedBy() default \"N/A\"; // Note use of array String[] reviewers(); } ~~~ interface关键字的使用让annotation定义看起来和接口类型定义类似，但前者用的是`@interface`。 定义的body包含该annotation类型的elements的声明，elements的声明看起来很像方法的声明。可以用default关键字提供可选的默认值。 定义完annotation类型后，我们就可以使用定义好的annotation了，注意填上elements的值： ~~~Java @ClassPreamble ( author \"John Doe\", date \"3/17/2002\", currentRevision 6, lastModified \"4/12/2004\", lastModifiedBy \"Jane Doe\", //Note array notation reviewers {\"Alice\", \"Bob\", \"Cindy\"} ) public class Generation3List extends Generation2List { // class code goes here } ~~~ 如果要让`@ClassPreamble`的内容出现在Javadoc生成的文档中，必须在`@ClassPreamble`的定义前使用`@Documented`： ~~~Java // import this to use @Documented import java.lang.annotation.*; @Documented @interface ClassPreamble { // annotation element definitions } ~~~ ## 预定义好的annotation类型 一系列annotation类型已经在Java SE API中预定义好了。有些annotation类型被编译器使用，有些则被其他annotation类型调用。 ### 被Java语言使用的annotation 预定义在java.lang包中的类型是`@Deprecated`（已弃用）、`@Override`（重载）和`@SuppressWarnings`（删除警告）。 `@Deprecated`类型表示被标记的Java特性已被弃用。编译器会生成一个warning不管何时有程序使用了被标记的方法、类和字段。当一个Java特性已被弃用时，还应该用Javadoc的`@deprecated`标签记录下来： ~~~Java // Javadoc comment follows /** * @deprecated * explanation of why it was deprecated */ @Deprecated static void deprecatedMethod() {...} ~~~ @符同时在Javadoc注释和annotation中被使用并不是巧合：他们在概念上是相关联的。同时，Javadoc标签使用小写字母d，而annotation使用大写字母D。 `@Override`类型告知编译器这个Java特性诣在重载超类中的Java特性： ~~~Java // mark method as a superclass method // that has been overridden @Override int overriddenMethod() {...} ~~~ 虽然并不强制要求在每个重载Java特性前加上`@Override`，但这有助于防止错误。如果一个被`@Override`标记的方法没有成功重载超类的方法，编译器会生成一个错误。 `@SuppressWarnings`类型告诉编译器删除特定的本来会生成的warnings。在下面的例子中，使用了一个已被弃用的方法，编译器会生成一个warning，但我们使用的`@SuppressWarnings`可以让这个warning被抑制。 ~~~Java // use a deprecated method and tell // compiler not to generate a warning @SuppressWarnings(\"deprecation\") void useDeprecatedMethod() { // deprecation warning // suppressed objectOne.deprecatedMethod(); } ~~~ 每个编译器warning都属于一个类别，Java语言规范列出了两个类别：deprecation和unchecked类别。unchecked警告发生在处理遗留代码的时候，这些遗留代码是在generics（泛型）出现之前被写的。如果想同时抑制两种类型的warning，使用下面的语法： ~~~Java @SuppressWarnings({\"unchecked\", \"deprecation\"}) ~~~ `@SafeVarargs`类型，当被用在一个方法或构造器上时，断言这段代码不会执行关于varargs参数的不安全操作。当这个annotation被使用时，与varargs参数使用相关的unchecked warnings会被抑制。 `@FunctionalInterface`类型，在Java SE 8中出现，表示下面的声明将会是Java语言规范定义的一个函数型接口。 ### 被其他annotation调用的annotation 被其他annotation调用的annotation被称为meta annotation。下面是几种预定义在java.lang.annotation包中的meta annotation。 `@Retention`类型规定了被标记的annotation的存储方式： RetentionPolicy.SOURCE——被标记的annotation只保留在源文件层，而会直接被编译器忽略。 RetentionPolicy.CLASS——被标记的annotaion在编译时仍被编译器保留，但会被JVM忽略。 RetentionPolicy.RUNTIME——被标记的annotation会被JVM保留，因此它可以被运行时环境使用。 `@Documented`类型表示不论何时使用了被标记的annotation，其elements都会被Javadoc记录。 `@Target`类型标记另一个annotation类型，以限制这个annotation类型能够被用于的Java特性。 `@Repeatable`类型，引入于Java SE 8，表示被标记的annotation类型可以在一个声明之上重复使用多次。 ## Type Annotations and Pluggable Type Systems"},"/Java/Java学习/文档注释——javadoc.html":{"title":"","content":"## javadoc简介 javadoc：由源文件生成HTML文档（Java的官方文档就是用javadoc生成的）。 javadoc从源文件中抽取以`/**......*/`为界的 特殊块注释 。 特殊块注释应放置在Java特性（模块，包，public类和接口，public或protected字段，public或protected构造器和方法）前面。 > 如果文档是面向使用类的用户或其他程序员，private特性不需要文档。但事实上，为了作者自己将来重构代码，肯定要为private特性编写注释或其他内部文档。 > protected特性也需要公开文档，这是为了方便继承。"},"/Java/Java学习/Java-基础IO.html":{"title":"Java 基础IO","content":"# Java 基础IO IO流（java.io） 字节流 所有字节流类继承自InputStream和OutputStream（如FileInputStream和FileOutputStream） InputStream.read()和OutputStream.write()都是一次读或写一个字节，可以用一个int接收read()的字节，占用int的最后8位 记得关闭流——close()，关闭之前还要判null 其他流都建立在字节流之上 使用流会引发IOException 字符流 Java使用Unicode标准。字符流自动在内部格式和电脑本地字符集之间转换。 所有字符流类继承自Reader和Writer（如FileReader和FileWriter） read()和write()一次读写一个字符，可以用一个int来接收read()的字符，占用int的最后16位 字符流是字节流的包装器 字节流使用字符流做物理IO，再在字符与字节之间进行转换。 桥流：InputStreamReader和OutputStreamWriter。用他们来定制想要的字符流。 面向行的IO。使用readline()和println()来读写行。 CRLF：carriage return/line feed，\\r\\n 缓冲流 之前的非缓冲流的读写请求直接由操作系统处理，触发磁盘访问等，开销很大。 缓冲输入流从被称为缓冲的内存区域读入，原生输入API只在缓冲为空时调用一次。 缓冲输出流也将数据写入缓冲，原生API只在缓冲为空时调用一次。 使用包装器将非缓冲流转换成缓冲流。 var inputStream new BufferedReader(new FileReader(\"xxx.txt\"); var outputStream new BufferedWriter(new FileWriter(\"xxx.txt\"); 刷新缓冲流 不等我们将缓冲流用满，就写出它，这被称为刷新缓冲。 有些输出缓冲流支持自动刷新，可以在构造缓冲流时通过一个参数来指定。自动刷新启用时，当某个关键事件被触发时，缓冲就被自动刷新 比如自动刷新的PrintWriter对象，每次调用println或format方法时，它会自动刷新。 要手动刷新缓冲，调用flush方法。flush方法对任何输出流有效。但如果输出流不是缓冲流，那flush方法就没效。 扫描与格式化 扫描scanning（将输入分解成各种数据） 默认情况下，scanner使用空白分隔输入数据 空白包括空格，制表符和换行，可以用Characer.isWhitespace()判断空白。 Scanner对象构造器需要一个输入流对象，而且Scanner类在java.util包中。 有hasNext()，next()方法 需要用close方法关闭Scanner以关闭其底层的输入流。 使用useDelimiter()方法改变默认的分隔符，参数是一个正则表达式。 除了将输入分隔数据看成字符串以外，还能看成其他类型 useLocale()方法设置Scanner的地区：s.useLocale(Locale.US); 可以将32,767识别为整数 hasNextDouble()，nextDouble() 格式化formatting（将输出组织成适当的格式） 实现格式设置的流对象是PrintWriter（字符流类）或PrintStream（字节流类）的实例。 这两个类除了基本的write()方法外，还实现了两种格式化输出方法 一种是print()和println()，用标准的方式格式化输出独立值 print(i)：重载print()方法，自动使用对应的print()函数输出i print(\"string\" + i)：先自动调用i.toString()，再输出合成的字符串。 一种是format()方法，提供许多选项精准格式化 详细信息参见： <https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax> 命令行的IO 标准流 java的System.in对应系统的标准输入流，System.out对应系统的标准输出流，System.err对应系统的标准错误流。 这些对象都是自动定义好了的。 分开的标准输出流和错误流可以让我们把输出重定向到文件里，但直接显示错误。 由于历史原因，这三个对象都是字节流，System.out和System.err定义为PrintWriter对象，尽管是字节流，但PrintWriter内部使用了一个字符流来效仿字符流的特性。 System.in是纯字节流，可用包装器转成字符流。 但更一般的使用方法是： Scanner in new Scanner(System.in); 控制台 系统有预定义好的Console类对象，不仅有大多数标准流提供的特性，还有其他特性，尤其是安全密码输入。Console类对象同时提供了输入流和输出流，并且是真正的字符流。 在使用Console类对象之前，必须检索操作系统提供的Console对象： Console c System.console(); 如果Console操作不可用，返回null 使用readPassword()方法进行密码输入 这时密码在控制台是不可见的 返回一个char数组，使用完后记得手动把这个数组覆盖 文件IO（java.nio.file）"},"/Java/常见报错.html":{"title":"常见报错","content":"# 常见报错 报错如下： ~~~text Error: Unable to initialize main class com.itranswarp.learnjava.AppConfig Caused by: java.lang.UnsupportedClassVersionError: org/apache/catalina/WebResourceRoot has been compiled by a more recent version of the Java Runtime (class file version 65.0), this version of the Java Runtime only recognizes class file versions up to 64.0 ~~~ 原因是编译得到的字节码（.class）版本太高（java 22），虚拟机（jvm）版本太低（java 20）。 将`tomcat`版本调低（11.0.0 M7 > 11.0.0 M6）就行了。"},"/Java/vscode中的logback.html":{"title":"vscode中的logback","content":"# vscode中的logback 导入三个包：`slf4j.jar` `logback classic.jar` `logback core.jar`，再设置好`logback.xml`。就可以使用了。 使用的时候，在类上添加一个`@Slf4j`注解，方法内就可以使用`log`对象了。 由于logback无法细节到格式化浮点数输出，所以要格式化浮点数，推荐使用`DecimalFormat`，具体使用可以参考: <https://blog.csdn.net/wdd1324/article/details/70153896>"},"/Java/Java学习/Java并发.html":{"title":"Java并发","content":"# Java并发 将能同时处理多个任务的软件称为并发软件 从Java5以来，Java平台就有了高并发API java.util.concurrent库 创建进程可以使用ProcessBuilder，但这超出了接下来的讨论范围。 Java并发目前只讨论线程 Thread对象 每个线程都和一个Thread对象相关联，有两种方法使用Thread对象创建并发程序 直接控制线程的创建和管理，当应用需要初始化一个异步任务时，每次都实例化Thread 要从应用程序的其余部分抽象线程管理，将应用程序的任务传递给一个executor。 定义并开始一个线程 要实例化Thread对象，必须提供将会运行在这个线程中的代码 给Thread构造器传入一个实现了Runnable接口的对象 创建继承自Thread的一个子类，然后重写Thread的run()方法 然后对创建的Thread对象调用start()方法。 上面的两种方法各有特点： 自己实现Runnable接口更具一般性，可以继承其他类 继承Thread用起来更方便，但父类必须是Thread会有所限制。 在高级线程管理API中，第一种更适用。 用睡眠停止线程的执行 静态方法Thread.sleep()暂停当前线程的执行 向sleep()方法传入一个整数，代表要睡眠的时间，默认单位是毫秒 sleep()不能保证精确的睡眠时间，因为这实际会被底层操作系统限制，并且睡眠期间还可能被中断型号终止。 sleep()方法抛出检查型异常InterruptedException。 当另一个线程中断了当前正在睡眠的线程时，sleep方法就抛出该异常 中断 一个中断信号表示这个线程应该停下现在的工作去做点别的。具体由程序员决定线程该如何响应中断。其中 在其他线程里对要中断的线程对象调用interupt()方法就能中断对应的线程。 要让中断机制正确工作，被中断的线程必须支持自己的中断。 受支持的中断 要被中断的线程调用抛出InterruptedException的方法（如sleep），即支持中断。 在try catch语句中，一般捕获到异常后直接返回。 如果一个线程很长时间没有调用抛出InterruptedException的方法怎么办？那么它必须定期调用Thread.interrupted()，如果收到中断信号，它将返回true。 当这个方法返回true时，再手动抛出InterruptedException异常更好，这样可以在外层嵌套中用try catch语句来集中处理异常。 中断状态标志 中断机制使用称为中断状态的内部标志实现。调用Thread.interrupt将设置此标志。当线程通过调用静态方法Thread.interrupted检查中断时，中断状态将被清除。非静态isInterrupted方法由一个线程用来查询另一个线程的中断状态，它不会更改中断状态标志。 按照约定，任何通过抛出InterruptedException退出的方法都会在抛出时清除中断状态。但是，总是有可能由另一个线程调用中断，立即再次设置中断状态。 join()方法 join()方法允许一个线程等待另一个线程的完成 可以重载join方法：传入指定的等待时间 join也会想sleep那样抛出InterruptedException异常 同步 线程主要通过共享对字段和引用字段引用的对象的访问来进行通信。这种形式的通信效率极高，但可能导致两种错误：线程干扰和内存一致性错误。防止这些错误所需的工具是同步。 但是，同步可能会引入线程争用，当两个或多个线程试图同时访问同一资源时会发生这种情况，并导致Java运行时更慢地执行一个或多个线程，甚至暂停它们的执行。饥饿和活锁都是线程争用的形式。有关详细信息，请参阅“活动性”一节。 Java语言提供了两种同步用法——同步的方法和同步的语句 同步方法 在方法声明中添加synchronized关键字 对同一个对象的两个同步方法的调用不可能交错。当一个线程正在执行某个对象的同步方法时，为同一对象调用同步方法的所有其他线程都会阻塞（挂起执行），直到第一个线程处理完该对象。 构造器不能是同步的，在构造器前加synchronized关键字引发语法错误。 同步语句 与同步方法不同，同步语句必须指定提供内部锁的对象 同步语句的好处 非同步方法里可以同步读写字段。对字段的读写一般必须是同步的，但可能这个方法里还会调用其他对象的方法 交错读写同一对象的多个字段。对象的同步方法直接锁住了整个对象，同时只能有一个线程读写字段，如果为每个字段对应创建一个用来提供锁的对象，就可以做到多个线程分别读写多个字段。 同步方法是通过内部锁实现的 当对一个对象调用同步方法时，自动获得该对象的内部锁，所有其他要调用该对象的同步方法的线程因无法获取锁而阻塞 方法返回时自动释放锁，即使发生了异常也会自动释放锁 静态同步方法的锁是类的Class对象的锁，该锁与类的任何实例的锁不同 一个线程不能获取另一个线程拥有的锁。但是线程可以获取它已经拥有的锁。允许线程多次获取同一锁将启用可重入同步。这描述了同步代码直接或间接调用也包含同步代码的方法，并且两组代码使用同一锁的情况。如果没有可重入同步，同步代码将不得不采取许多额外的预防措施，以避免线程导致自身阻塞。 活动性liveness 死锁——两个或多个线程被永久阻塞、相互等待的情况。 饥饿——一个线程总是不能正常访问一个共享资源，一般是其他线程频繁调用共享对象的同步方法 活锁——一个线程经常响应另一个线程的操作而执行操作。如果另一个线程的动作也是对另一个线程的动作的响应，则可能导致活锁。与死锁一样，活锁线程无法继续前进。然而，线程并没有被阻塞 它们只是忙碌响应彼此而无法继续工作。 受保护的块 线程间经常要协调它们的活动。最常见的协调写法被称为受保护的块。 这样的块通过轮询一个条件开始，只有条件为真时线程才能继续。 比如，两个线程（A和B）间用一个共享的boolean变量flag来通信。A用一个while循环来判断flag是否为真，只有当B将flag设置为真时，A才能向下执行。 while循环内应该用Object.wait()来停止本线程。 当前线程必须拥有Object的锁才能调用wait()方法，否则抛出异常。调用后，当前线程自动释放锁，并等待被其他线程用notify或notifyAll方法唤醒，然后继续等待，直到重新获得锁，然后wait()返回，继续执行。 在单参数版本中，中断和伪唤醒是可能的，并且此方法应始终在循环中使用 使用受保护的块的方法（如guardedBlocks()）应该是同步的（synchronized），while循环里直接对本实例对象调用wait()（即this.wait()，编写guardedBlocks()方法时可省略this）。 因为wait方法要求线程拥有对象的锁，如果guardedBlocks()方法不是同步的，调用wait时，锁可能在其他线程里，就调用失败了。将guardedBlocks()方法设置为同步的，调用wait时，锁必然在当前线程中。"},"/Java/Java学习/Java-json.html":{"title":"Java-json","content":"# Java json json基础 特性 只允许用UTF 8编码 只允许使用双引号作为key，如\"name\"，特殊字符用反斜杠转义 只支持以下几种数据类型： 键值对：{\"key\": value} 数组：[1, 2, 3] 字符串：\"abc\" 数值（整数和浮点数）：12.34 布尔值：true或false 空值：null fastjson <https://github.com/alibaba/fastjson/wiki/Samples DataBind>"},"/Java/Java学习/protected.html":{"title":"","content":"超类中protected方法或字段： 1. 只允许自己和子类访问 2. 若子类和超类不在同一个包中，子类中的方法只能访问子类实例的protected字段或方法，而不能访问超类实例的protected字段或方法 比如，tmp1包中有一个SuperClass类，它是tmp2包中SubClass类的超类。 SuperClass类有两个protected字段state1和state2，还有一个private字段p1，这个private字段配有一个protected访问器getp1()。 SubClass类有一个方法`void test(SuperClass sup, SubClass sub)`，在这个方法中是无法调用sup.getp1()和sup.state2的，可以正常调用sub.getp1()和sub.state2。这就表示了第二条：子类和超类不在同一个包中，子类方法中只能访问子类实例的protected字段或方法，而不能访问超类实例的protected字段或方法"},"/Java/Java学习/包Package.html":{"title":"","content":"解释如何将类和接口打包进package，如何使用在package中的类，如何管理文件系统使得编译器可以找到源文件。 ## 为什么要使用package 为了让Java types更容易找到和使用、避免命名冲突和控制访问，程序员将相关的类型装进package中。 > [!Note] Definition > 一个package是一组提供访问保护和命名空间管理的相关联Java types。注意这里的types指的是class、interface、enumeration还有annotation类型。enumeration和annotation类型分别是特殊的class和interface，因此在这里，types指的是class和interface。 作为Java平台关键部分的types，是各种按功能打包class的package的成员：比如基础class在java.lang包里，用于读写（输入输出）的class在java.io里，等等。我们也可以把自定义的types放进package里。 假设我们写了一组表示图形对象的class，比如圆、矩形、线和点，我们还写了一个interface——Draggable，之前的class如果要能被鼠标拖动就要实现这个接口： ~~~Java // in the Draggable.java file public interface Draggable { ... } // in the Graphic.java file public abstract class Graphic { ... } // in the Circle.java file public class Circle extends Graphic implements Draggable { ... } // in the Rectangle.java file public class Rectangle extends Graphic implements Draggable { ... } // in the Point.java file public class Point extends Graphic implements Draggable { ... } // in the Line.java file public class Line extends Graphic implements Draggable { ... } ~~~ 出于不少于以下几个原因，我们应该将这些class和这个interface装进一个包： 所有人可以一目了然这些types是相关的； 所有人可以知道在哪找到提供图形相关方法的types； package创建了一个命名空间，因此我们types的名字不会和其他package的types的名字冲突； package中的types对package中的另一个type访问没有限制，但是这个package之外的types访问package内的types是有限制的。 ## 创建一个package 要创建一个package，首先要确定这个package的名字（命名规范在后面会提到），然后在这些包含types的源文件的顶部加上一条语句： ~~~Java package packagename; ~~~ 这条语句必须在源文件的第一行！每一个源文件只能有一条语句，这会对文件中的所有types起作用。 > [!Note] > 如果要放多个types在一个源文件中，只有一个type可以为public，并且这个type的名字必须和源文件相同。 > 虽然可以将non public types和public type放在同一文件中（强烈不推荐除非non public types特别小并且和public type有紧密联系），但只有public type可以被package之外的types访问。所有的top level non public types都是*package private*（可被package之内的types访问，不可被package之外的types访问） 如果将之前的一个interface和五个class装进一个名为graphics的package中，会得到下面这样的六个源文件： ~~~Java // in the Draggable.java file package graphics; public interface Draggable { ... } // in the Graphic.java file package graphics; public abstract class Graphic { ... } // in the Circle.java file package graphics; public class Circle extends Graphic implements Draggable { ... } // in the Rectangle.java file package graphics; public class Rectangle extends Graphic implements Draggable { ... } // in the Point.java file package graphics; public class Point extends Graphic implements Draggable { ... } // in the Line.java file package graphics; public class Line extends Graphic implements Draggable { ... } ~~~ （唯一变化就是每个文件顶部多了一条`package graphics;`语句） 如果没有`package graphics;`语句，这个类型最终属于一个无名package。一般来说，无名package只被用于小而临时的用途，或者，刚刚开始进行开发。否则，应将class和interface放在命名了的package中。 ## 为package命名 由于全世界有广泛的程序员使用Java语言来写class和interface，非常可能许多程序员为不同的types使用相同的名字。事实上，在上面的例子中就已经出现了：我们定义了一个Rectangle class，但在java.awt package中已经存在了一个Rectangle class了。但如果这两个class在不同package中，编译器就允许它们同名。每个Rectangle class的fully qualified name（完全限定名）包括package名。在graphics package中的Rectangle的fully qualified name是graphics.Rectangle，java.awt package中的Rectangle class的fully qualified name是java.awt.Rectangle。 这样看来很有效，除非两个独立的程序员使用同一个package名。如何防止这种情况发生呢？命名规范。 ### 命名规范Naming Conventions package名全部使用小写字母以防和class名或interface名冲突。 公司使用该公司的翻转了的互联网域名作为package名的开头：比如，package名`com.example.mypackage`是example.com下的程序员创建的一个名为mypackage的package。 公司内部的命名冲突需要由公司内部的规范自行解决，可能通过加上地区或项目名称来解决：`com.example.region.mypackage`。 Java语言本身的package以java.或javax.开头。 一些情况下，域名不是一个有效package名。当域名包含一个连字符或其他特殊字符时，或当package名以数字或其他不能作为Java命名开头的字符时，又或者package包含Java关键字时，域名不是一个有效的package名。在这种情况下，推荐的规范是加一个下划线： Domain Name Package Name Prefix hyphenated name.example.org org.example.hyphenated_name example.int int_.example 123name.example.com com.example.\\_123name ## 使用package成员 组成package的types被称为package members（成员）。 要从外部使用一个public package member，必须通过以下方式之一： 使用fully qualified name描述这个member； 使用`import`关键字导入该package member； 使用`import`关键字导入包含该package member的整个package。 每一种方法都有适用的不同情况。 ### 使用fully qualified name"},"/Java/Java学习/Java日期和时间API（java-time）.html":{"title":"Java日期和时间API（java.time）","content":"# Java日期和时间API（java.time） 日期时间API使用ISO 8601日历系统，基于公历日历系统，全球范围内被用作事实上的日期时间标准 核心类包括LocalDateTime，ZonedDateTime，OffsetDateTime 日期时间API使用 Unicode Common Locale Data Repository (CLDR)，包括了全世界最大的地区数据集合，其中的信息被本地化为了上百种语言 还使用了时区数据库（TZDB），提供了自时区这一概念提出以来的所有信息。 API设计原则 明确 API的表现是明确且可预期的 流畅 大部分方法不允许传入null且不返回null；方法可以链式调用；结果代码能被快速理解 不可变 大部分对象是不可变的，常用带有of，from，with的方法创建对象，没有set方法 可扩展 可定义自己的时间调整器，甚至日历系统 日期时间包 整个API由java.time及其四个字包组成 Java.time 核心包，有各种类 java.time.chrono 代表ISO 8601以外的日历系统 java.time.format 有用来格式化和解析的类 java.time.temporal 扩展API，主要用于框架和库编写器，允许日期和时间类之间的互操作、查询和调整。字段（TemporalField和ChronoField）和单位（TemporalUnit和ChronoUnit）在此包中定义。 java.time.zone 支持时区、时区偏移量和时区规则的类。如果使用时区，大多数开发人员只需要使用ZonedDateTime和ZoneId或ZoneOffset。 方法命名规范 Date Time API在一组丰富的类中提供了一组丰富的方法。只要可能，类之间的方法名就保持一致。例如，许多类提供了now方法，该方法捕获与该类相关的当前时刻的日期或时间值。有一些from方法允许从一个类转换到另一个类。"},"/Java/Java学习/Java对象访问限制.html":{"title":"Java对象访问限制","content":"# Java对象访问限制 类修饰符 public 可被所有其他类访问 不指定修饰符 仅可被同一包中其他类访问（package private) 成员修饰符 public或不指定修饰符 与类情况相同 private 仅可被同一类的其他成员访问 protect 可被同一包中其他类访问 或其他包中的子类（子类仅可访问自己的成员，不可访问超类的成员，因为不在同一个包中） Java官网只说子类能访问超类protected成员，显然是不完整的"}}