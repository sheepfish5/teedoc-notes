{"/Docker/index.html":{"title":"Docker","content":" title: Docker keywords: Docker date: 2023 07 19 关于Docker的学习内容"},"/Docker/零碎问题.html":{"title":"零碎问题","content":"# 零碎问题 ## 1. 指定下载镜像的特定架构 ~~~bash docker pull platform linux/arm64 klo2k/nexus3 ~~~ ## 2. 从本地文件导入镜像时标签为`none` 要解决这个问题，需要导出时正确指定标签： ~~~bash docker save o rsync/nexus3.tar klo2k/nexus3:lates ~~~ 之后再导入时应该就能正常显示标签： ~~~bash docker load i rsync/nexus3.tar # Loaded image: klo2k/nexus3:latest ~~~ 如果导入时使用的是`image id`的前几个字符： ~~~bash docker save o rsync/nexus3.tar 7337 ~~~ 再按之前的方法导入，最后的标签就会是`<none>`，可以通过手动给这个`image`打标签来亡羊补牢： ~~~bash docker tag [IMAGE_ID] [REPOSITORY]:[TAG] ~~~ ## 3. 各种清理命令 ~~~bash docker image prune # 删除所有没有关系容器的dangling image docker image prune a # 删除所有没有关联容器的image docker container prune # 删除所有终止的容器 docker volume prune # 删除所有不被容器引用的匿名数据卷 docker volume prune a # 删除任何不被容器引用的数据卷 ~~~ 其实这些命令在执行的时候都会有相对应的提示：`WARNING! This will remove anonymous local volumes not used by at least one container.`。 推荐使用` help`选项，信息非常简短友好。"},"/Docker/--privileged选项.html":{"title":"`--privileged`选项","content":"# ` privileged`选项 通过docker部署v2raya时，官方文档中使用了` privileged`选项。 根据docker官方文档，` privileged`标志为容器提供所有功能。当操作员执行`docker run privileged`时，Docker将启用对主机上所有设备的访问，并在AppArmor或SELinux中设置一些配置，以允许容器对主机的访问几乎与在主机上的容器外部运行的进程相同。有关使用` privileged`运行的更多信息，请访问[Docker博客][def]。 [def]: https://www.docker.com/blog/docker can now run within docker/?_gl 1*i5uajp*_ga*MTkyOTI2MzM1OC4xNjc5ODA3OTI5*_ga_XJWPQMJYHQ*MTY4NzQ4OTUyNi4xMi4xLjE2ODc0ODk2MjQuNjAuMC4w"},"/Docker/ONBUILD指令的理解.html":{"title":"ONBUILD指令的理解","content":"# ONBUILD指令的理解 ONBUILD 指令可以为镜像添加触发器。²⁴ 其参数是任意一个 Dockerfile 指令。² 当我们在一个 Dockerfile 文件中加上 ONBUILD 指令，该指令对利用该 Dockerfile 构建镜像（比如为 A 镜像）不会产生实质性影响。² 但是当我们编写一个新的 Dockerfile 文件来基于 A 镜像构建一个镜像（比如为 B 镜像）时，这时构造 A 镜像的 Dockerfile 文件中的 ONBUILD 指令就生效了，在构建 B 镜像的过程中，首先会执行 ONBUILD 指令指定的指令，然后才会执行其它指令。² ONBUILD 指令的作用是在父镜像向子镜像传递一些指令，让子镜像在构建时执行。¹³ 这样可以减少 Dockerfile 文件的重复内容编写，也可以实现一些通用的操作。² ONBUILD 指令只能在构建子镜像时执行，对孙子镜像构建无效。² 这是为了避免重复执行相同的指令，造成不必要的开销。³ ONBUILD 指令的语法格式如下： ~~~Dockerfile ONBUILD <INSTRUCTION> ~~~ 其中，`<INSTRUCTION>` 是任意一个有效的 Dockerfile 指令，除了 FROM、MAINTAINER 和 ONBUILD 本身。¹³ 例如： ~~~text ONBUILD RUN mkdir mydir ~~~ 这条指令表示在子镜像构建时，在根目录下创建一个名为 mydir 的目录。 源: 与必应的对话， 6/22/2023 (1) docker学习笔记17：Dockerfile 指令 ONBUILD介绍 51kata 博客园. <https://www.cnblogs.com/51kata/p/5265107.html>. (2) Dockerfile ONBUILD命令详解_onbuild run_金麟十三少的博客 CSDN博客. <https://blog.csdn.net/u012373281/article/details/113624065>. (3) Using ONBUILD instruction dockerlabs. <https://dockerlabs.collabnix.com/beginners/using onbuild images/>. (4) How to Use Dockerfile ONBUILD to Run Triggers on Downstream Builds. <https://www.howtogeek.com/devops/how to use dockerfile onbuild to run triggers on downstream builds/>. (5) 【Docker】Dockerfile 最佳实践 ONBUILD 波尔 博客园. <https://www.cnblogs.com/jiangbo4444/p/14218238.html>."},"/Docker/挂载主机tmpfs到docker容器内.html":{"title":"挂载主机tmpfs到docker容器内","content":"# 挂载主机tmpfs到docker容器内 来源：[docker官网手册](https://docs.docker.com/storage/tmpfs/) 挂载docker数据卷（volumes）和目录绑定允许您在主机和容器之间共享文件，以便即使在容器停止后也可以持久保存数据。 如果你在Linux上运行Docker，你有第三个选择：tmpfs挂载。当您使用tmpfs挂载创建容器时，该容器可以在容器的可写层之外（宿主机内存）创建文件。 与数据卷和目录绑定相反，tmpfs挂载是临时的，只会持久保存在主机内存中。当容器停止时，tmpfs挂载将被删除，写入其中的文件将不会被持久化。 这对于临时存储您不希望保留在主机或容器可写层中的敏感文件非常有用。"}}