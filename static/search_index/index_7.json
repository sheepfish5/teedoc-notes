{"/JavaScript/index.html":{"title":"JavaScript","content":" title: JavaScript keywords: JavaScript date: 2023 07 19 关于JavaScript的学习内容"},"/JavaScript/基础/事件冒泡和事件捕获.html":{"title":"事件冒泡和事件捕获","content":"# 事件冒泡和事件捕获 参考：稀土掘金 <https://juejin.cn/post/7192584563799883832> 简单来说，事件的传递是先从外层元素向内传递，直到最内层元素，然后再从最内层元素向外传递，直到最外层元素。从外向内的第一阶段就是事件捕获，从内向外的第二阶段就是事件冒泡。可以通过`addEventListener()`的第三个参数来设置事件冒泡还是事件捕获，**默认使用事件冒泡**，即从内向外传递。"},"/JavaScript/基础/解释闭包.html":{"title":"解释闭包","content":"# 解释闭包 参考：[MDN 闭包及其应用](https://developer.mozilla.org/zh CN/docs/Web/JavaScript/Closures) ~~~javascript function makeAdder(x) { return function (y) { return x + y; }; } var add5 makeAdder(5); var add10 makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 ~~~ 上面的代码中，`add5`和`add10`都有着各自的私有作用域，里面有变量`x`的定义，像这样保存了不同的词法环境的函数，以及声明该函数的词法环境的组合，就叫做*闭包*。补充一点，有时不一定是函数，比如javascript对象加上其独特的作用域，也算是闭包。"},"/JavaScript/基础/函数里的this.html":{"title":"函数里的`this`","content":"# 函数里的`this` ## `function`关键字定义的函数 使用`function`关键字声明的函数的函数体是一层新的变量作用域。函数体里面用`var`声明的变量与外界隔开。 ~~~text ┌───────────────────────────────┐ │ VariableScope1 │ │ │ │ var a, b, c; │ │ │ │ ┌────────────────────────┐ │ │ │ function func() │ │ │ │ │ │ │ │ VariableScope2 │ │ │ │ │ │ │ │ var a, b, c; │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └────────────────────────┘ │ │ │ └───────────────────────────────┘ ~~~ `use strict`模式下，使用`function`关键字声明的函数中，可以使用`this`关键字。这个`this`绑定的对象是动态的，如果该函数对象以对象方法的形式`obj.func()`被调用，那么里面的`this`就指向对象`obj`本身，或者说绑定到`obj`；如果该函数对象以正常函数的形式`func()`被调用，那么里面的`this`就为`undefined`。 ## 箭头函数` >` 箭头函数不是匿名函数的语法糖，完全是一个新的东西。箭头函数的变量作用域与上面说的完全不同： ~~~text ┌────────────────────────────────────────────┐ │ VariableScope1 │ │ │ │ var [a,b,c] [1,2,3]; │ │ │ │ │ │ var func () > { return a * b * c; }; │ │ │ │ │ │ │ └────────────────────────────────────────────┘ ~~~ 箭头函数不会搞出一个新的变量作用域，而是直接用外层原本的变量作用域`VariableScope1`。 这也使得箭头函数里理论上是没有`this`关键字的！如果用了`this`关键字，实际上用的是`VariableScope1`里的`this`。具体表现为`use strict`模式下，如果外层是全局作用域，那么`this`就是`undefined`；如果外层是个使用`function`关键字声明的函数，那么箭头函数里的`this`就是外层函数里的`this`。 多说一句，javascript给了程序员这么大的自由真的不好，学的时候要记这么多的且繁琐的规则，用的时候又容易出错。"},"/JavaScript/基础/词法作用域.html":{"title":"词法作用域","content":"# 词法作用域 参考：<https://www.freecodecamp.org/chinese/news/javascript lexical scope tutorial/> 提炼一下： **作用域**表示一个区间，在这个区间内声明的所有内容（比如方法或变量）都可以被该区间内的代码访问到。 **词法（Lexical）**指的是定义某个事物。 **词法作用域（Lexical Scope）**是定义表达式并能被访问的区间，即表达式被定义时所在的作用域。 关键在于词法作用域的意义：只有词法作用域内的代码才可以访问该作用域内部的代码。比如在一个函数内的作用域上定义一个变量，那么该变量的词法作用域就是这个函数作用域，只有写在该变量的词法作用域内的代码才能访问该变量，写在这个函数之外的代码不能直接访问该变量。"},"/JavaScript/基础/async和await.html":{"title":"`async`和`await`","content":"# `async`和`await` 从结果来说，由`async`声明的函数和普通函数没有什么不同，其中的javascript代码都是同步执行的。 主要差别在于`async`函数中`await`关键字的效果。 [MDN文档中][MDN]已经说的很详细了，这里再总结下：在`await`之前，`async`函数都是同步执行，执行到`await`后的异步操作时（如`fetch(url)`），浏览器就使用其他线程或进程执行网络或文件读取等操作，javascript主线程就可以将`async`函数直接返回一个Promise对象，然后继续顺序执行。等`async`函数内的`await`操作结束后，javascript主线程再回到`async`函数中继续往下执行。补充两点，`async`函数的`return`子句和`await`表达式都是直接返回Promise所代理的对象，比如`await fetch(url)`直接返回`response`对象。 [MDN]: https://developer.mozilla.org/zh CN/docs/Web/JavaScript/Reference/Statements/async_function"},"/JavaScript/基础/javascript单线程的理解.html":{"title":"javascript单线程的理解","content":"# javascript单线程的理解 以下都来自ChatGPT的对话。 ## 请问如何理解javascript是单线程的？ JavaScript是一种单线程编程语言，这意味着它只能同时执行一个任务。具体来说，JavaScript代码是按顺序执行的，**从上到下逐行执行，每行代码都会阻塞后续代码的执行，直到当前行代码执行完毕才会执行下一行。** 这是因为JavaScript的设计初衷是在浏览器中处理用户交互，例如响应按钮点击、处理表单提交等。**单线程的设计可以保证多个交互事件按照顺序被处理，避免了资源竞争和数据访问冲突的问题。** 然而，JavaScript也提供了一些机制来处理一些异步操作，例如：定时器函数、事件监听器和AJAX请求。这些异步操作可以在后台执行，不会阻塞主线程的执行。当异步操作完成后，将会触发相应的回调函数，以便处理结果。 尽管JavaScript是单线程的，但通过合理使用异步操作和回调函数，可以实现并发执行的效果，提高程序的性能和响应能力。 ## 那javascript是如何实现异步编程的？ JavaScript通过**任务队列**和**事件循环机制**来实现异步编程。 在JavaScript中，当需要执行一些耗时的操作时，比如从服务器加载数据、读取文件等，传统的同步方式会导致程序阻塞，直到操作完成才能继续执行后续代码。为了解决这个问题，JavaScript引入了异步编程模型。 异步编程通过将任务交给其他线程或进程处理，然后在任务完成后通知主线程继续执行后续代码。而JavaScript是单线程的，所以异步任务的实现使用了任务队列和事件循环机制。 任务队列是用来保存异步任务的队列，每个异步任务完成后都会被放入任务队列中。而事件循环机制则负责不断地检查任务队列，**当主线程空闲时，会从任务队列中取出一个任务，并执行相应的代码**。 常见的异步编程方式包括回调函数、Promise和async/await。回调函数是最早被广泛使用的方式，通过传递一个函数作为参数，在异步任务完成后调用该函数。Promise则是ES6引入的一种更为友好的方式，通过Promise对象可以更简洁地处理异步任务的状态和结果。async/await是ES2017引入的语法糖，更直观地表达异步代码的执行顺序，使代码看起来更像是同步的。 总之，通过任务队列和事件循环机制，JavaScript能够实现高效的异步编程，提升代码的性能和用户体验。 ### 请问你所说的javascript主线程是只负责执行javascript代码吗？如果是的话，那事件循环机制是靠其他线程执行的吗？ 是的，JavaScript主线程负责执行JavaScript代码。但是，**事件循环机制并不是由其他线程执行的，而是由JavaScript主线程自身管理**。当JavaScript主线程执行完所有的同步代码后，会从任务队列（task queue）中取出一个任务，然后执行该任务。这个过程是反复进行的，称为事件循环（event loop）。也就是说，JavaScript主线程是负责在任务队列中取出任务并执行的。 ### 那javascript主线程也负责将异步任务放入任务队列吗？ 是的，JavaScript主线程负责执行同步代码，并且当遇到异步任务时，将其放入任务队列中等待执行。这些异步任务可以是定时器、事件监听器、网络请求等。一旦主线程完成当前执行的任务，它会轮询任务队列，并将队列中的第一个任务取出执行。这种机制被称为事件循环(Event Loop)。所以，JavaScript主线程负责管理同步和异步任务的执行顺序。 总结一下就是任务队列和事件循环机制都是javascript主线程自己负责的，而那些具体的异步任务会分派到其他线程执行。 *无法保证ChatGPT的话完全正确，但估计也八九不离十。*"},"/JavaScript/基础/理解基于Promise的API.html":{"title":"理解基于Promise的API","content":"# 理解基于Promise的API ## 回顾一下`Promise`调用过程 ~~~javascript console.log('before async'); fetch(url) .then((response) > { if (!response.ok) { throw new Error(`HTTP 错误: ${response.status}`); } return response.text(); }) .then((text) > poemDisplay.textContent text) .catch((error) > poemDisplay.textContent `获取诗歌失败：${error}`); console.log('after async'); ~~~ 以`fetch(url)`为例，调用完函数后，函数立即返回Promise对象，后续两个`then()`函数在返回的Promise对象上注册处理函数，最后`catch()`函数注册异常处理函数。`fetch()`返回后，javascript主线程继续向下执行`console.log('after async');`，同时浏览器后台可以通过其他线程或进程执行网络操作，这些非javascript操作成功结束后，javascript主线程将之前注册了的两个处理函数加入到任务队列中，等待空闲时再执行，也就是说，`fetch(url)`函数内部的操作不归javascript管，但处理函数的注册与执行、加入任务队列，以及任务队列本身都归javascript管。 ## 自己编写基于Promise的API ~~~javascript function alarm(person, delay) { return new Promise((resolve, reject) > { if (delay < 0) { throw new Error('Alarm delay must not be negative'); } window.setTimeout(() > { // 将这个看作真正的浏览器使用其他线程或进程执行的网络操作。 resolve(`Wake up, ${person}!`); }, delay); }); } ~~~ 函数`alarm()`与`fetch()`类似，也是返回一个Promised对象，其他操作也都类似，就不再赘述。 具体看看`alarm()`函数的内部。事实上，`alarm()`就是一个普通函数，如果其内部有一些普通javascript同步代码，javascript就正常同步执行。最后返回一个新创建的Promise对象，Promise对象的构造器需要一个执行器函数，这个函数是Promise异步操作的关键。 > 这个执行器本身采用两个参数，这两个参数都是函数，通常被称作 `resolve` 和 `reject`。在你的执行器实现里，你调用原始的异步函数。如果异步函数成功了，就调用 `resolve`，如果失败了，就调用 `reject`。如果执行器函数抛出了一个错误，`reject` 会被自动调用。你可以将任何类型的单个参数传递到 `resolve` 和 `reject` 中。 总之，执行器函数内通过调用`resole()`和`reject()`设置Promise对象的状态。 这个执行器函数会在 Promise 对象被创建时立即执行，这个动作也是同步的，执行器内部的javascript代码也同步执行，一直到开启真正的异步操作（这里以`window.setTimeout()`进行模拟），这时，由浏览器安排其他线程或进程进行网络或文件读取等操作，然后javascript主线程继续向下执行，直到执行完执行器函数。再之后，就创建完Promise对象了，不过由于`resole()`和`reject()`函数尚未被调用，Promise对象的状态还是`pending`。`alarm()`将创建好的Promise对象返回，然后由`then()`方法注册处理函数，再之后，javascript主线程继续向下执行。 一段时间后，异步操作结束，正如`window.setTimeout()`里所写，由javascript调用`resole()`或`reject()`设置Promise对象状态为`fulfilled`或`rejected`，然后javascript主线程将注册的处理函数或异常处理函数加到任务队列中。后续处理之前已经说过了。虽然不常用，但如果真正来写基于Promise的异步API时，执行器函数中，`resole()`和`reject()`两个函数要写到异步操作里。"}}